<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://evansalien.github.io</id>
    <title>Evans Alien</title>
    <updated>2020-03-09T01:18:02.228Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://evansalien.github.io"/>
    <link rel="self" href="https://evansalien.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://evansalien.github.io/images/avatar.png</logo>
    <icon>https://evansalien.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Evans Alien</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 call, apply, bind]]></title>
        <id>https://evansalien.github.io/post/javascript_call-apply-bind/</id>
        <link href="https://evansalien.github.io/post/javascript_call-apply-bind/">
        </link>
        <updated>2020-03-06T06:57:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="call-apply-bin区别">call、apply 、 bin区别</h1>
<h2 id="call-call-方法在使用一个指定的-this-值和若干个指定的参数值的前提下调用某个函数或方法">call: call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</h2>
<pre><code class="language-javascript">  var foo = {
    value: 1,
  };

  function bar() {
    console.log(this.value);
  }

  bar.call(foo); // 1

  // 1. call 改变了this的指向，指向到了foo

  // 2. bar 函数执行了
</code></pre>
<p><strong>模拟实现call</strong></p>
<pre><code class="language-javascript">  // 如何模拟上面这两个步骤呢？

  // 试想调用call的时候，把foo对象该找成如下效果

  var foo = {
    value: 1,
    bar: function () {
      console.log(this.value)
    }
  };

  foo.bar(); // 1

  // 这个时候 this 就指向了 foo，是不是很简单呢？

  // 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！

  // 不过也不用担心，我们用 delete 再删除它不就好了~

  // 所以可以模拟拆分步骤

  // 1. 将函数设为对象的属性 foo.fn = bar

  // 2. 执行该函数 foo.fn()

  // 3. 删除该函数 delete foo.fn

  Function.prototype.call1 = function(context) {
    context.fn = this;
    context.fn();
    delete context.fn;
  }

  // 测试一下
  var foo = {
    value: 1
  };
  
  function bar () {
    console.log(this.value)
  }

  bar.call1(foo); // 1

  // 正好可以打印1，那如果传入多个参数呢？

  // 我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里

  Function.prototype.call2 = function(context) {
    var context = context || window; // 如果不传则this为window
    context.fn = this

    var arg = [];
    for (var i = 1, len = arguments.length; i &lt; len; i++) {
      args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
  }

  // 测试一下
  var value = 2;

  var obj = {
      value: 1
  }

  function bar(name, age) {
      console.log(this.value);
      return {
          value: this.value,
          name: name,
          age: age
      }
  }

  bar.call(null); // 2

  console.log(bar.call2(obj, 'kevin', 18));
  // 1
  // Object {
  //    value: 1,
  //    name: 'kevin',
  //    age: 18
  // }

</code></pre>
<p><strong>模拟实现applay</strong></p>
<pre><code class="language-javascript">  // 其实apply的实现跟call类似
  
  Function.prototype.apply1 = function(context, arr) {
    var context = Object(ocntext) || window;
    context.fn = this;

    var result;
    if (!arr) {
      result = context.fn();
    } else {
      var arg = [];
      for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push('arr[' + i + ']');
        }
      result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
  }

</code></pre>
<h2 id="bind-bind-方法会创建一个新函数-当这个新函数被调用时bind-的第一个参数将作为它运行时的-this之后的一序列参数将会在传递的实参前传入作为它的参数">bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</h2>
<pre><code class="language-javascript">  // 由上面的介绍可以得到两点的结论

  // 1. 返回一个函数
  // 2. 可以传入函数

  var foo = {
    value: 1
  };

  function bar() {
    console.log(this.value);
  }

  var bindFoo = bar.bind1(foo);

  bindFoo() // 1

  Function.prototype.bind1 = function(context) {
    var self = this;
    return function() {
      self.apply(context);
    }
  }


  // 因为 bind 还有一个特点，就是: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

  // 换句话来说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：

  var value = 2;

  var foo = {
      value: 1
  };

  function bar(name, age) {
      this.habit = 'shopping';
      console.log(this.value);
      console.log(name);
      console.log(age);
  }

  bar.prototype.friend = 'kevin';

  var bindFoo = bar.bind(foo, 'daisy');

  var obj = new bindFoo('18');
  // undefined
  // daisy
  // 18
  console.log(obj.habit);
  console.log(obj.friend);
  // shopping
  // kevin

  // 尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了

  // 所以我们可以通过修改返回函数的原型来实现

  Function.prototype.bind2 = function(context) {
    if (typeof this !== 'function') {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var fbound = function () {
      var bindArgs = Array.prototype.slice.call(arguments);
      // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。

      // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
      self.apply(this instanceof self ? this : context, args.concat(bindArgs));
    }

    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值
    fbound.prototype = this.prototype;

    return fbound;
  }


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript this关键字]]></title>
        <id>https://evansalien.github.io/post/javascript_this/</id>
        <link href="https://evansalien.github.io/post/javascript_this/">
        </link>
        <updated>2020-03-05T06:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。<br>
但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。其主要隐式绑定场景讨论：</p>
<ol>
<li>全局上下文🌲</li>
<li>直接函数调用和对象方法形式调用🌳</li>
<li>DOM时间绑定🎄</li>
<li>new 构造函数绑定🌴</li>
<li>箭头函数🌱</li>
</ol>
<h2 id="全局上下文">🌲全局上下文</h2>
<blockquote>
<p>这个不用多少了吧，默认指向Window, 严格模式下是 undefined。</p>
</blockquote>
<h2 id="直接函数调用和对象方法形式调用">🌳直接函数调用和对象方法形式调用</h2>
<pre><code class="language-javascript">var obj = {
    fn: function() {
        console.log(this.a);
    },
    a: 1,
}
var a = 2;
var fn = obj.fn;
fn(); // 2
obj.fn(); // 1
</code></pre>
<blockquote>
<p>这种两种情况调用，<strong>this</strong>相当于是<strong>Window</strong>和 <strong>obj</strong>。</p>
</blockquote>
<h2 id="dom事件绑定">🎄DOM事件绑定</h2>
<blockquote>
<p>onclick和addEventerListener中 this 默认指向绑定事件的元素。IE比较奇异，使用attachEvent，里面的this默认指向window。</p>
</blockquote>
<h2 id="new-构造函数绑定">🌴 new 构造函数绑定</h2>
<blockquote>
<p>此时构造函数中的this指向实例对象。</p>
</blockquote>
<h2 id="箭头函数">🌱 箭头函数</h2>
<blockquote>
<p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。</p>
</blockquote>
<pre><code class="language-javascript">var obj = {
  a: function() {
    var fn = () =&gt; {
      console.log(this);
    }
    fn();
  }
}
obj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj
</code></pre>
]]></content>
    </entry>
</feed>