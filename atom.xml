<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://evansalien.github.io</id>
    <title>Evans Alien</title>
    <updated>2020-03-10T05:48:49.835Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://evansalien.github.io"/>
    <link rel="self" href="https://evansalien.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://evansalien.github.io/images/avatar.png</logo>
    <icon>https://evansalien.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Evans Alien</rights>
    <entry>
        <title type="html"><![CDATA[浏览器的组成]]></title>
        <id>https://evansalien.github.io/post/liu-lan-qi-de-zu-cheng/</id>
        <link href="https://evansalien.github.io/post/liu-lan-qi-de-zu-cheng/">
        </link>
        <updated>2020-03-10T02:39:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器的主要结构">浏览器的主要结构</h2>
<ul>
<li>
<p>用户界面</p>
</li>
<li>
<p>浏览器引擎（负责窗口的管理、tab进程管理...）</p>
</li>
<li>
<p>渲染引擎（内核，负责HTML解析，页面渲染）</p>
</li>
<li>
<p>JS引擎（JS解释器，V8, chakra, javascrriptcore...）</p>
</li>
</ul>
<p><strong>主讲浏览器核心的渲染引擎和JS引擎</strong></p>
<h2 id="从进程和线程角度来了解浏览器工作">从进程和线程角度来了解浏览器工作</h2>
<h3 id="进程和线程">进程和线程</h3>
<ul>
<li>
<p>进程是cpu资源分配的最小单位（能拥有资源和独立运行的最小单位）</p>
</li>
<li>
<p>线程是cpu调度的最小单位（线程是建立在进程基础上的一个程序运行单位，一个进程可以拥有多个线程）</p>
</li>
</ul>
<p><strong>进程可以类比为工厂，线程就是工厂里面的工人，一个工厂可以包含一个或者多个工人，工人之间可以相互协作，并且共享工作空间</strong></p>
<h3 id="浏览器的多进程架构">浏览器的多进程架构</h3>
<p>现代的浏览器采用的都是多进程架构，主要包含以下三种进程：</p>
<ul>
<li>
<p>Browser进程<br>
<strong>浏览器的主线程，主要负责浏览器的页面管理、书签、前进后退、资源下载管理等，整个浏览器应用程序只有一个，对应上述浏览器组成中的浏览器引擎。</strong></p>
</li>
<li>
<p>渲染进程<br>
<strong>内核进程、负责页面渲染、JS执行，对应的是上述的渲染引擎和JS引擎，一个浏览器可以包含多个渲染进程，每个Tab窗口页对应一个渲染进程</strong></p>
</li>
<li>
<p>GPU进程<br>
<strong>负责GPU渲染，整个浏览器应用程序只有一个</strong></p>
</li>
<li>
<p>插件进程<br>
<strong>浏览器安装的插件(扩展程序)，每个插件会创建一个进程</strong></p>
</li>
</ul>
<p>如下图：<br>
<img src="https://evansalien.github.io/post-images/1583809456713.jpg" alt="" loading="lazy"></p>
<p><strong>拥有3个插件进程，3个浏览器进程1个GPU进程1个网络进程</strong></p>
<p>这种多进程浏览器架构的优势 :</p>
<ul>
<li>
<p>避免单个页面奔溃影响整个浏览器</p>
</li>
<li>
<p>避免第三方插件奔溃影响整个浏览器</p>
</li>
<li>
<p>充分利用多核优势</p>
</li>
</ul>
<h3 id="浏览器的渲染进程">浏览器的渲染进程</h3>
<ul>
<li>
<p>浏览器有多个渲染进程、一个Tab页面一个（相同的Tab页面会被合并）</p>
</li>
<li>
<p>一个渲染进程包含多个线程</p>
</li>
</ul>
<p><strong>一个渲染进程主要包括如下线程：</strong></p>
<p>1.GUI线程(主要负责解析HTML、CSS和渲染页面)</p>
<p>2.JS引擎线程(负责解析和执行JS代码)</p>
<p>3.事件线程(控制事件循环)</p>
<p>4.定时器线程(处理定时器相关逻辑)</p>
<p>5.异步请求线程(发起Ajax时会生成该线程)</p>
<p><strong>线程规则如下</strong></p>
<ul>
<li>
<p><strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起，页面的更新操作会等到JS引擎空闲时执行，涉及任务和微任务相关知识</p>
</li>
<li>
<p>一个渲染进程同时只有一个JS解析线程在运行</p>
</li>
<li>
<p>JS引擎线程不停的处理事件线程推送到事件队列中的任务</p>
</li>
<li>
<p>定时器和异步请求最终生成的回调事件也有事件线程来控制和管理了解了浏览器的渲染进程之后我们再来看看JS引擎。</p>
</li>
</ul>
<h3 id="从实践循环的角度理解js引擎工作的过程">从实践循环的角度理解JS引擎工作的过程</h3>
<p><strong>同步与异步</strong></p>
<p>同步是代码执行后可以获得想要的结果，异步是指代码执行后不能立即获得想要的结果</p>
<p><strong>同步任务和异步任务</strong></p>
<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而是由事件线程调度，在满足执行条件的时候放到事件队列中，等待主线程(JS线程)的执行。</p>
<p><strong>循环事件的概念</strong></p>
<p>JS包含异步操作（Ajax, 定时器），这些异步操作完成之后要通知JS引擎来处理异步操作返回的结果，（Ajax的CallBack）。这些异步操作什么时候完成的是不确定的，所以需要一个事件队列，事件线程将已经完成的异步操作的回调任务加载到事件队列中，JS引擎在执行完当前的同步任务之后循环从事件队列中取事件执行。</p>
<p><strong>异步任务</strong></p>
<pre><code>setTimeout, setTnterval, Promise, process.nextTick(NodeJs), Ajax
</code></pre>
<p>异步任务统一有事件线程管理，当异步任务完成的时候会被放入到事件队列中，JS在顺序执行完当前的代码之后会从事件队列中读取任务，再重复整个流程，判断该任务是同步还是异步</p>
<figure data-type="image" tabindex="1"><img src="https://evansalien.github.io/post-images/1583817990649.png" alt="" loading="lazy"></figure>
<p><strong>异步任务的优先级</strong></p>
<p>如果按照上述的简化理解，所有异步任务都按照满足执行条件的顺序放到事件队列中，世界很和平，先来先到，但是在ES6当中，引入了microtask的概念，microtask会在当前的任务执行完成之后立即执行。因为我们将异步任务分为task和microtask，我们又称为宏任务和微任务。</p>
<pre><code>task: setTImeout、setInterval、ajax

microtask：MutationObserve、promise、process.nextTick(Node.js)
</code></pre>
<p>这样子加了优先级的话JS的执行又会变得再复杂一点，如下图所示，异步任务执行完成之后会判断他是task还是microtask，再分别加到不同的时间队列中，JS当前任务执行完成之后优先清空当前的microtask队列，而且在每次执行完宏任务的时候都会去清空微任务。</p>
<figure data-type="image" tabindex="2"><img src="https://evansalien.github.io/post-images/1583818100784.png" alt="" loading="lazy"></figure>
<p>如下demo:<br>
<img src="https://evansalien.github.io/post-images/1583818807797.png" alt="" loading="lazy"></p>
<p>执行后</p>
<ol>
<li>click</li>
<li>promise</li>
<li>timeout</li>
</ol>
<p><strong>UI渲染线程什么时候工作</strong></p>
<p>UI渲染线程会在当前的Task执行完成之后，下一个Task执行之前执行，微任务会优先于UI渲染线程，这就意味着我们使用微任务更新的DOM能更快的被渲染出来。另外Vue.js最新版本数据变更的时候采用的是promise和MutationObserver创建微任务</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器-事件机制]]></title>
        <id>https://evansalien.github.io/post/liu-lan-qi-shi-jian-ji-zhi/</id>
        <link href="https://evansalien.github.io/post/liu-lan-qi-shi-jian-ji-zhi/">
        </link>
        <updated>2020-03-09T09:24:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="事件触发三个阶段">事件触发三个阶段</h2>
<h3 id="事件触发有三个阶段">事件触发有三个阶段</h3>
<ul>
<li><strong>window</strong>往事件触发出传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处往<strong>window</strong>传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。<br>
<img src="https://evansalien.github.io/post-images/1583746493173.png" alt="" loading="lazy"></p>
<h2 id="注册事件">注册事件</h2>
<p>通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li>capture，布尔值，和 useCapture 作用一样</li>
<li>once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听</li>
<li>passive，布尔值，表示永远不会调用 preventDefault</li>
</ul>
<p>一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。<br>
<img src="https://evansalien.github.io/post-images/1583746844308.png" alt="" loading="lazy"></p>
<h2 id="事件代理">事件代理</h2>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
<figure data-type="image" tabindex="1"><img src="https://evansalien.github.io/post-images/1583746938029.png" alt="" loading="lazy"></figure>
<p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EventLoop]]></title>
        <id>https://evansalien.github.io/post/eventloop/</id>
        <link href="https://evansalien.github.io/post/eventloop/">
        </link>
        <updated>2020-03-09T05:11:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="如何理解eventloop的宏任务和微任务">如何理解EventLoop的宏任务和微任务</h1>
<h2 id="宏任务-macrotask-引入">宏任务 (MacroTask) 引入</h2>
<p><strong>在JS中，大部分的任务都是主线程上执行，常见的任务有：</strong></p>
<pre><code>1. 渲染事件
2. 用户交互事件
3. js脚本执行
4. 网络请求、文件读写完成事件等等

bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
</code></pre>
<p><strong>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行 ，但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务</strong></p>
<h2 id="微任务-microtask-引入">微任务 (MicroTask) 引入</h2>
<p><strong>对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？</strong><br /><br>
<strong>其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</strong></p>
<pre><code>1. 将异步回调进行宏任务队列的入队操作。
2. 将异步回调放到当前宏任务的末尾。
</code></pre>
<p><strong>如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</strong><br>
<strong>为了规避这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</strong></p>
<p>常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。</p>
<p><strong>Ok, 这便是宏任务和微任务的概念，接下来正式介绍JS非常重要的运行机制——EventLoop。</strong></p>
<h2 id="如何理解eventloop浏览器">如何理解EventLoop——浏览器</h2>
<pre><code class="language-javascript">  console.log('start');
  setTimeout(() =&gt; {
    console.log('timeout');
  });
  Promise.resolve().then(() =&gt; {
    console.log('resolve');
  });
  console.log('end');

  
  // console.log('start')
  // async function test1 () {
  //   console.log('test1 start')
  //   await test2()
  //   console.log('test1 end')
  // }
  // setTimeout(() =&gt; {
  //   console.log('setTimeout')
  // }, 0)
  // new Promise(function (resolve) {
  //   console.log('promise start')
  //   resolve();
  // }).then(res =&gt; {
  //   console.log('promise end')
  // })
  // async function test2() {
  //   console.log('test2 start')
  // }
  // test1()
  // console.log('end')

  // start 
  // promise start
  // test1 start
  // test2 start
  // end
  // promise end
  // test1 end
  // setTimeout

</code></pre>
<p><strong>我们来分析一下：</strong></p>
<pre><code>1. 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈中，进行执行，因此先打印start和end
2. setTimeout 作为一个宏任务放入宏任务队列
3. Promise.then作为一个为微任务放入到微任务队列
4. 当本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行
5. 接下来进入到下一个宏任务——setTimeout, 执行
</code></pre>
<p>所以输出的是：</p>
<pre><code>// start
// end
// resolve
// timeout
</code></pre>
<p><strong>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结</strong></p>
<pre><code>1. 一开始整段脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空
</code></pre>
<p><strong>经典面试题</strong></p>
<pre><code class="language-javascript">async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  return 'async return';
}

async function async2() {
  console.log(&quot;async2&quot;);
}

console.log(&quot;script start&quot;);

setTimeout(function() {
  console.log(&quot;setTimeout&quot;);
}, 0);

async1().then(function (message) { console.log(message) });

new Promise(function(resolve) {
  console.log(&quot;promise1&quot;);
  resolve();
}).then(function() {
  console.log(&quot;promise2&quot;);
});

console.log(&quot;script end&quot;);
</code></pre>
<h2 id="如何理解eventloopnodejs">如何理解EventLoop——nodejs</h2>
<p><strong>nodejs和浏览器的eventLoop还是有很大的差别的，先来看一张node的eventLoop流程图吧</strong><br>
<img src="https://evansalien.github.io/post-images/1583730932501.png" alt="" loading="lazy"></p>
<p><strong>别说你，我第一时间看这个也是一面懵，不急慢慢来拆分nodej的事件循环机制</strong></p>
<h3 id="三大关键阶段">三大关键阶段</h3>
<p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p>
<pre><code>1. 执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。

2. 轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过'data'、'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后: 

如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。

如果没有定时器, 会去看回调函数队列。

(1) 如果队列不为空，拿出队列中的方法一次执行

(2) 如果队列为空，检查是否有 setImmdiate 的回调
    
    a. 有则前往check阶段(下面会说)

    b. 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段

1. check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。    
</code></pre>
<p><strong>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善</strong></p>
<h3 id="完善">完善</h3>
<p><strong>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</strong></p>
<p><strong>并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。</strong></p>
<p><strong>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</strong></p>
<pre><code>1. timer 阶段
2. I/O 异常回调阶段
3. 空闲、预备状态(第2阶段结束，poll 未触发之前)
4. poll 阶段
5. check 阶段
6. 关闭事件的回调阶段
</code></pre>
<pre><code class="language-javascript">  setTimeout(()=&gt;{
      console.log('timer1')
      Promise.resolve().then(function() {
          console.log('promise1')
      })
  }, 0)
  setTimeout(()=&gt;{
      console.log('timer2')
      Promise.resolve().then(function() {
          console.log('promise2')
      })
  }, 0)
  // timer1
  // promise1
  // time2
  // promise2
</code></pre>
<h3 id="nodejs-和-浏览器关于eventloop的主要区别">nodejs 和 浏览器关于eventLoop的主要区别</h3>
<p><strong>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</strong></p>
<h3 id="关于processnexttick的一点说明">关于process.nextTick的一点说明</h3>
<p><strong>process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 call, apply, bind]]></title>
        <id>https://evansalien.github.io/post/javascript_call-apply-bind/</id>
        <link href="https://evansalien.github.io/post/javascript_call-apply-bind/">
        </link>
        <updated>2020-03-06T06:57:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="call-apply-bin区别">call、apply 、 bin区别</h1>
<h2 id="call-call-方法在使用一个指定的-this-值和若干个指定的参数值的前提下调用某个函数或方法">call: call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</h2>
<pre><code class="language-javascript">  var foo = {
    value: 1,
  };

  function bar() {
    console.log(this.value);
  }

  bar.call(foo); // 1

  // 1. call 改变了this的指向，指向到了foo

  // 2. bar 函数执行了
</code></pre>
<p><strong>模拟实现call</strong></p>
<pre><code class="language-javascript">  // 如何模拟上面这两个步骤呢？

  // 试想调用call的时候，把foo对象该找成如下效果

  var foo = {
    value: 1,
    bar: function () {
      console.log(this.value)
    }
  };

  foo.bar(); // 1

  // 这个时候 this 就指向了 foo，是不是很简单呢？

  // 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！

  // 不过也不用担心，我们用 delete 再删除它不就好了~

  // 所以可以模拟拆分步骤

  // 1. 将函数设为对象的属性 foo.fn = bar

  // 2. 执行该函数 foo.fn()

  // 3. 删除该函数 delete foo.fn

  Function.prototype.call1 = function(context) {
    context.fn = this;
    context.fn();
    delete context.fn;
  }

  // 测试一下
  var foo = {
    value: 1
  };
  
  function bar () {
    console.log(this.value)
  }

  bar.call1(foo); // 1

  // 正好可以打印1，那如果传入多个参数呢？

  // 我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里

  Function.prototype.call2 = function(context) {
    var context = context || window; // 如果不传则this为window
    context.fn = this

    var arg = [];
    for (var i = 1, len = arguments.length; i &lt; len; i++) {
      args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
  }

  // 测试一下
  var value = 2;

  var obj = {
      value: 1
  }

  function bar(name, age) {
      console.log(this.value);
      return {
          value: this.value,
          name: name,
          age: age
      }
  }

  bar.call(null); // 2

  console.log(bar.call2(obj, 'kevin', 18));
  // 1
  // Object {
  //    value: 1,
  //    name: 'kevin',
  //    age: 18
  // }

</code></pre>
<p><strong>模拟实现applay</strong></p>
<pre><code class="language-javascript">  // 其实apply的实现跟call类似
  
  Function.prototype.apply1 = function(context, arr) {
    var context = Object(ocntext) || window;
    context.fn = this;

    var result;
    if (!arr) {
      result = context.fn();
    } else {
      var arg = [];
      for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push('arr[' + i + ']');
        }
      result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
  }

</code></pre>
<h2 id="bind-bind-方法会创建一个新函数-当这个新函数被调用时bind-的第一个参数将作为它运行时的-this之后的一序列参数将会在传递的实参前传入作为它的参数">bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</h2>
<pre><code class="language-javascript">  // 由上面的介绍可以得到两点的结论

  // 1. 返回一个函数
  // 2. 可以传入函数

  var foo = {
    value: 1
  };

  function bar() {
    console.log(this.value);
  }

  var bindFoo = bar.bind1(foo);

  bindFoo() // 1

  Function.prototype.bind1 = function(context) {
    var self = this;
    return function() {
      self.apply(context);
    }
  }


  // 因为 bind 还有一个特点，就是: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

  // 换句话来说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：

  var value = 2;

  var foo = {
      value: 1
  };

  function bar(name, age) {
      this.habit = 'shopping';
      console.log(this.value);
      console.log(name);
      console.log(age);
  }

  bar.prototype.friend = 'kevin';

  var bindFoo = bar.bind(foo, 'daisy');

  var obj = new bindFoo('18');
  // undefined
  // daisy
  // 18
  console.log(obj.habit);
  console.log(obj.friend);
  // shopping
  // kevin

  // 尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了

  // 所以我们可以通过修改返回函数的原型来实现

  Function.prototype.bind2 = function(context) {
    if (typeof this !== 'function') {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var fbound = function () {
      var bindArgs = Array.prototype.slice.call(arguments);
      // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。

      // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
      self.apply(this instanceof self ? this : context, args.concat(bindArgs));
    }

    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值
    fbound.prototype = this.prototype;

    return fbound;
  }


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript this关键字]]></title>
        <id>https://evansalien.github.io/post/javascript_this/</id>
        <link href="https://evansalien.github.io/post/javascript_this/">
        </link>
        <updated>2020-03-05T06:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。<br>
但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。其主要隐式绑定场景讨论：</p>
<ol>
<li>全局上下文🌲</li>
<li>直接函数调用和对象方法形式调用🌳</li>
<li>DOM时间绑定🎄</li>
<li>new 构造函数绑定🌴</li>
<li>箭头函数🌱</li>
</ol>
<h2 id="全局上下文">🌲全局上下文</h2>
<blockquote>
<p>这个不用多少了吧，默认指向Window, 严格模式下是 undefined。</p>
</blockquote>
<h2 id="直接函数调用和对象方法形式调用">🌳直接函数调用和对象方法形式调用</h2>
<pre><code class="language-javascript">var obj = {
    fn: function() {
        console.log(this.a);
    },
    a: 1,
}
var a = 2;
var fn = obj.fn;
fn(); // 2
obj.fn(); // 1
</code></pre>
<blockquote>
<p>这种两种情况调用，<strong>this</strong>相当于是<strong>Window</strong>和 <strong>obj</strong>。</p>
</blockquote>
<h2 id="dom事件绑定">🎄DOM事件绑定</h2>
<blockquote>
<p>onclick和addEventerListener中 this 默认指向绑定事件的元素。IE比较奇异，使用attachEvent，里面的this默认指向window。</p>
</blockquote>
<h2 id="new-构造函数绑定">🌴 new 构造函数绑定</h2>
<blockquote>
<p>此时构造函数中的this指向实例对象。</p>
</blockquote>
<h2 id="箭头函数">🌱 箭头函数</h2>
<blockquote>
<p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。</p>
</blockquote>
<pre><code class="language-javascript">var obj = {
  a: function() {
    var fn = () =&gt; {
      console.log(this);
    }
    fn();
  }
}
obj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj
</code></pre>
]]></content>
    </entry>
</feed>