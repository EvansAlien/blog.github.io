<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://evansalien.github.io</id>
    <title>Evans Alien</title>
    <updated>2020-03-09T05:23:22.735Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://evansalien.github.io"/>
    <link rel="self" href="https://evansalien.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://evansalien.github.io/images/avatar.png</logo>
    <icon>https://evansalien.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Evans Alien</rights>
    <entry>
        <title type="html"><![CDATA[EventLoop]]></title>
        <id>https://evansalien.github.io/post/eventloop/</id>
        <link href="https://evansalien.github.io/post/eventloop/">
        </link>
        <updated>2020-03-09T05:11:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="如何理解eventloop的宏任务和微任务">如何理解EventLoop的宏任务和微任务</h1>
<h2 id="宏任务-macrotask-引入">宏任务 (MacroTask) 引入</h2>
<p><strong>在JS中，大部分的任务都是主线程上执行，常见的任务有：</strong></p>
<pre><code>1. 渲染事件
2. 用户交互事件
3. js脚本执行
4. 网络请求、文件读写完成事件等等

bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
</code></pre>
<p><strong>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行 ，但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务</strong></p>
<h2 id="微任务-microtask-引入">微任务 (MicroTask) 引入</h2>
<p><strong>对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？</strong><br /><br>
<strong>其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</strong></p>
<pre><code>1. 将异步回调进行宏任务队列的入队操作。
2. 将异步回调放到当前宏任务的末尾。
</code></pre>
<p><strong>如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</strong><br>
<strong>为了规避这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</strong></p>
<p>常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。</p>
<p><strong>Ok, 这便是宏任务和微任务的概念，接下来正式介绍JS非常重要的运行机制——EventLoop。</strong></p>
<h2 id="如何理解eventloop浏览器">如何理解EventLoop——浏览器</h2>
<pre><code class="language-javascript">  console.log('start');
  setTimeout(() =&gt; {
    console.log('timeout');
  });
  Promise.resolve().then(() =&gt; {
    console.log('resolve');
  });
  console.log('end');

  
  // console.log('start')
  // async function test1 () {
  //   console.log('test1 start')
  //   await test2()
  //   console.log('test1 end')
  // }
  // setTimeout(() =&gt; {
  //   console.log('setTimeout')
  // }, 0)
  // new Promise(function (resolve) {
  //   console.log('promise start')
  //   resolve();
  // }).then(res =&gt; {
  //   console.log('promise end')
  // })
  // async function test2() {
  //   console.log('test2 start')
  // }
  // test1()
  // console.log('end')

  // start 
  // promise start
  // test1 start
  // test2 start
  // end
  // promise end
  // test1 end
  // setTimeout

</code></pre>
<p><strong>我们来分析一下：</strong></p>
<pre><code>1. 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈中，进行执行，因此先打印start和end
2. setTimeout 作为一个宏任务放入宏任务队列
3. Promise.then作为一个为微任务放入到微任务队列
4. 当本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行
5. 接下来进入到下一个宏任务——setTimeout, 执行
</code></pre>
<p>所以输出的是：</p>
<pre><code>// start
// end
// resolve
// timeout
</code></pre>
<p><strong>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结</strong></p>
<pre><code>1. 一开始整段脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空
</code></pre>
<p><strong>经典面试题</strong></p>
<pre><code class="language-javascript">async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  return 'async return';
}

async function async2() {
  console.log(&quot;async2&quot;);
}

console.log(&quot;script start&quot;);

setTimeout(function() {
  console.log(&quot;setTimeout&quot;);
}, 0);

async1().then(function (message) { console.log(message) });

new Promise(function(resolve) {
  console.log(&quot;promise1&quot;);
  resolve();
}).then(function() {
  console.log(&quot;promise2&quot;);
});

console.log(&quot;script end&quot;);
</code></pre>
<h2 id="如何理解eventloopnodejs">如何理解EventLoop——nodejs</h2>
<p><strong>nodejs和浏览器的eventLoop还是有很大的差别的，先来看一张node的eventLoop流程图吧</strong><br>
<img src="https://evansalien.github.io/post-images/1583730932501.png" alt="" loading="lazy"></p>
<p><strong>别说你，我第一时间看这个也是一面懵，不急慢慢来拆分nodej的事件循环机制</strong></p>
<h3 id="三大关键阶段">三大关键阶段</h3>
<p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p>
<pre><code>1. 执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。

2. 轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过'data'、'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后: 

如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。

如果没有定时器, 会去看回调函数队列。

(1) 如果队列不为空，拿出队列中的方法一次执行

(2) 如果队列为空，检查是否有 setImmdiate 的回调
    
    a. 有则前往check阶段(下面会说)

    b. 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段

1. check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。    
</code></pre>
<p><strong>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善</strong></p>
<h3 id="完善">完善</h3>
<p><strong>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</strong></p>
<p><strong>并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。</strong></p>
<p><strong>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</strong></p>
<pre><code>1. timer 阶段
2. I/O 异常回调阶段
3. 空闲、预备状态(第2阶段结束，poll 未触发之前)
4. poll 阶段
5. check 阶段
6. 关闭事件的回调阶段
</code></pre>
<pre><code class="language-javascript">  setTimeout(()=&gt;{
      console.log('timer1')
      Promise.resolve().then(function() {
          console.log('promise1')
      })
  }, 0)
  setTimeout(()=&gt;{
      console.log('timer2')
      Promise.resolve().then(function() {
          console.log('promise2')
      })
  }, 0)
  // timer1
  // promise1
  // time2
  // promise2
</code></pre>
<h3 id="nodejs-和-浏览器关于eventloop的主要区别">nodejs 和 浏览器关于eventLoop的主要区别</h3>
<p><strong>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</strong></p>
<h3 id="关于processnexttick的一点说明">关于process.nextTick的一点说明</h3>
<p><strong>process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 中的 call, apply, bind]]></title>
        <id>https://evansalien.github.io/post/javascript_call-apply-bind/</id>
        <link href="https://evansalien.github.io/post/javascript_call-apply-bind/">
        </link>
        <updated>2020-03-06T06:57:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="call-apply-bin区别">call、apply 、 bin区别</h1>
<h2 id="call-call-方法在使用一个指定的-this-值和若干个指定的参数值的前提下调用某个函数或方法">call: call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</h2>
<pre><code class="language-javascript">  var foo = {
    value: 1,
  };

  function bar() {
    console.log(this.value);
  }

  bar.call(foo); // 1

  // 1. call 改变了this的指向，指向到了foo

  // 2. bar 函数执行了
</code></pre>
<p><strong>模拟实现call</strong></p>
<pre><code class="language-javascript">  // 如何模拟上面这两个步骤呢？

  // 试想调用call的时候，把foo对象该找成如下效果

  var foo = {
    value: 1,
    bar: function () {
      console.log(this.value)
    }
  };

  foo.bar(); // 1

  // 这个时候 this 就指向了 foo，是不是很简单呢？

  // 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！

  // 不过也不用担心，我们用 delete 再删除它不就好了~

  // 所以可以模拟拆分步骤

  // 1. 将函数设为对象的属性 foo.fn = bar

  // 2. 执行该函数 foo.fn()

  // 3. 删除该函数 delete foo.fn

  Function.prototype.call1 = function(context) {
    context.fn = this;
    context.fn();
    delete context.fn;
  }

  // 测试一下
  var foo = {
    value: 1
  };
  
  function bar () {
    console.log(this.value)
  }

  bar.call1(foo); // 1

  // 正好可以打印1，那如果传入多个参数呢？

  // 我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里

  Function.prototype.call2 = function(context) {
    var context = context || window; // 如果不传则this为window
    context.fn = this

    var arg = [];
    for (var i = 1, len = arguments.length; i &lt; len; i++) {
      args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
  }

  // 测试一下
  var value = 2;

  var obj = {
      value: 1
  }

  function bar(name, age) {
      console.log(this.value);
      return {
          value: this.value,
          name: name,
          age: age
      }
  }

  bar.call(null); // 2

  console.log(bar.call2(obj, 'kevin', 18));
  // 1
  // Object {
  //    value: 1,
  //    name: 'kevin',
  //    age: 18
  // }

</code></pre>
<p><strong>模拟实现applay</strong></p>
<pre><code class="language-javascript">  // 其实apply的实现跟call类似
  
  Function.prototype.apply1 = function(context, arr) {
    var context = Object(ocntext) || window;
    context.fn = this;

    var result;
    if (!arr) {
      result = context.fn();
    } else {
      var arg = [];
      for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push('arr[' + i + ']');
        }
      result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
  }

</code></pre>
<h2 id="bind-bind-方法会创建一个新函数-当这个新函数被调用时bind-的第一个参数将作为它运行时的-this之后的一序列参数将会在传递的实参前传入作为它的参数">bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</h2>
<pre><code class="language-javascript">  // 由上面的介绍可以得到两点的结论

  // 1. 返回一个函数
  // 2. 可以传入函数

  var foo = {
    value: 1
  };

  function bar() {
    console.log(this.value);
  }

  var bindFoo = bar.bind1(foo);

  bindFoo() // 1

  Function.prototype.bind1 = function(context) {
    var self = this;
    return function() {
      self.apply(context);
    }
  }


  // 因为 bind 还有一个特点，就是: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

  // 换句话来说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：

  var value = 2;

  var foo = {
      value: 1
  };

  function bar(name, age) {
      this.habit = 'shopping';
      console.log(this.value);
      console.log(name);
      console.log(age);
  }

  bar.prototype.friend = 'kevin';

  var bindFoo = bar.bind(foo, 'daisy');

  var obj = new bindFoo('18');
  // undefined
  // daisy
  // 18
  console.log(obj.habit);
  console.log(obj.friend);
  // shopping
  // kevin

  // 尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了

  // 所以我们可以通过修改返回函数的原型来实现

  Function.prototype.bind2 = function(context) {
    if (typeof this !== 'function') {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var fbound = function () {
      var bindArgs = Array.prototype.slice.call(arguments);
      // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。

      // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
      self.apply(this instanceof self ? this : context, args.concat(bindArgs));
    }

    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值
    fbound.prototype = this.prototype;

    return fbound;
  }


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript this关键字]]></title>
        <id>https://evansalien.github.io/post/javascript_this/</id>
        <link href="https://evansalien.github.io/post/javascript_this/">
        </link>
        <updated>2020-03-05T06:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。<br>
但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。其主要隐式绑定场景讨论：</p>
<ol>
<li>全局上下文🌲</li>
<li>直接函数调用和对象方法形式调用🌳</li>
<li>DOM时间绑定🎄</li>
<li>new 构造函数绑定🌴</li>
<li>箭头函数🌱</li>
</ol>
<h2 id="全局上下文">🌲全局上下文</h2>
<blockquote>
<p>这个不用多少了吧，默认指向Window, 严格模式下是 undefined。</p>
</blockquote>
<h2 id="直接函数调用和对象方法形式调用">🌳直接函数调用和对象方法形式调用</h2>
<pre><code class="language-javascript">var obj = {
    fn: function() {
        console.log(this.a);
    },
    a: 1,
}
var a = 2;
var fn = obj.fn;
fn(); // 2
obj.fn(); // 1
</code></pre>
<blockquote>
<p>这种两种情况调用，<strong>this</strong>相当于是<strong>Window</strong>和 <strong>obj</strong>。</p>
</blockquote>
<h2 id="dom事件绑定">🎄DOM事件绑定</h2>
<blockquote>
<p>onclick和addEventerListener中 this 默认指向绑定事件的元素。IE比较奇异，使用attachEvent，里面的this默认指向window。</p>
</blockquote>
<h2 id="new-构造函数绑定">🌴 new 构造函数绑定</h2>
<blockquote>
<p>此时构造函数中的this指向实例对象。</p>
</blockquote>
<h2 id="箭头函数">🌱 箭头函数</h2>
<blockquote>
<p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。</p>
</blockquote>
<pre><code class="language-javascript">var obj = {
  a: function() {
    var fn = () =&gt; {
      console.log(this);
    }
    fn();
  }
}
obj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj
</code></pre>
]]></content>
    </entry>
</feed>